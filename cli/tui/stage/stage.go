package stage

import (
	"bytes"
	"strconv"
	"time"

	"github.com/alecthomas/chroma/quick"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type Model struct {
	Name  string
	Tasks []Task

	cursor int
	error  string
	done   bool
	width  int

	styles Styles
}

// Styles contains style definitions for this list component. By default, these
// values are generated by DefaultStyles.
type Styles struct {
	Header          lipgloss.Style
	Task            lipgloss.Style
	ActiveTaskColor lipgloss.Color
}

// DefaultStyles returns a set of default style definitions for this table.
func DefaultStyles() Styles {
	return Styles{
		Header: lipgloss.NewStyle().
			Border(lipgloss.DoubleBorder(), true).
			BorderForeground(lipgloss.Color("240")).
			Padding(0, 1, 0, 1).
			Bold(false),
		Task: lipgloss.NewStyle().
			Padding(0, 1, 0, 1).
			Border(lipgloss.NormalBorder(), true).
			BorderForeground(lipgloss.Color("240")),
		ActiveTaskColor: lipgloss.Color("212"),
	}
}

// SetStyles sets the table styles.
func (m *Model) SetStyles(s Styles) {
	m.styles = s
}

// Option is used to set options in New. For example:
//
//	stage := New(WithTasks([]Task{{Name: "Task 1"}}))
type Option func(*Model)

// New creates a new model for the table widget.
func New(name string, opts ...Option) Model {
	m := Model{
		Name: name,

		cursor: 0,
		width:  60,
		styles: DefaultStyles(),
	}

	for _, opt := range opts {
		opt(&m)
	}

	return m
}

func WithTasks(tasks []Task) Option {
	return func(m *Model) {
		m.Tasks = tasks
	}
}

// WithWidth sets the width of the stage.
func WithWidth(w int) Option {
	return func(m *Model) {
		m.width = w
	}
}

/**
 * Commands
 */
type TaskComplete struct {
	Status  TaskStatus
	Message string
}

/**
 * State
 */
type TaskStatus int

const (
	NotStarted TaskStatus = iota
	Complete
	Failed
)

type Task struct {
	Name    string
	Message string
	Status  TaskStatus
	Func    func() TaskComplete
}

func (m Model) Init() tea.Cmd {
	return func() tea.Msg {
		time.Sleep(time.Second * 2)

		return TaskComplete{
			Status: Complete,
		}
	}
}

func (m Model) View() string {
	return lipgloss.NewStyle().
		MarginBottom(1).
		Render(
			lipgloss.JoinVertical(
				lipgloss.Left,
				m.headerView(),
				m.tasksView(),
			),
		)

	// var items []string
	//
	// for i, _ := range m.tasks {
	//                m.renderTask(i)
	// 	items = append(items,
	// 		listItem,
	// 		message,
	// 	)
	// }
	//
	// body := lipgloss.JoinVertical(
	// 	lipgloss.Left,
	// 	items...,
	// )
	//
	// box := lipgloss.JoinVertical(
	// 	lipgloss.Left,
	// 	headerStyle.Render(m.stage),
	// 	bodyStyle.Render(body),
	// )
	//
	// var error string
	// if m.error != "" {
	// 	errorHeader := lipgloss.JoinHorizontal(
	// 		lipgloss.Left,
	// 		errorTitle.Render("ERROR:"),
	// 		currentTask.Name,
	// 	)
	//
	// 	error =
	// 		lipgloss.JoinVertical(
	// 			lipgloss.Left,
	// 			errorHeaderStyle.Render(errorHeader),
	// 			errorBodyStyle.Render(m.error),
	// 		)
	// }
	//
	// return wrapperStyle.Render(
	// 	lipgloss.JoinVertical(lipgloss.Left, box, error),
	// )
}

/**
 * Messages
 */

func (m Model) CurrentTask() *Task {
	return &m.Tasks[m.cursor]
}

func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {

	case tea.KeyMsg:
		switch msg.String() {
		case "esc", "q", "ctrl+c":
			return m, tea.Quit

		default:
			// log.Infof("You pressed: %s", msg.String())
			return m, nil
		}

	case TaskComplete:
		currentTask := m.CurrentTask()
		currentTask.Status = msg.Status

		// No not continue on error
		if msg.Status == Failed {
			m.error = msg.Message
			return m, tea.Quit
		}

		if m.cursor == len(m.Tasks)-1 {
			m.done = true
			return m, tea.Quit
		}

		m.cursor++

		return m, func() tea.Msg { return currentTask.Func() }

	default:
		return m, nil
	}
}

/**
 * Formatting
 */
func codeBlock(in string) string {
	buf := new(bytes.Buffer)
	_ = quick.Highlight(buf, in, "bash", "terminal256", "catppuccin-latte")
	return buf.String()
}

func renderStatus(status TaskStatus) string {
	switch status {
	case Complete:
		return lipgloss.NewStyle().Foreground(lipgloss.Color("#3eab21")).Render("DONE")
	case Failed:
		return lipgloss.NewStyle().Foreground(lipgloss.Color("#fea9a2")).Render("FAIL")

	default:
		return lipgloss.NewStyle().Foreground(lipgloss.Color("#999")).Render("PEND")
	}
}

func (m *Model) headerView() string {
	return m.styles.Header.Width(m.width - 2).Render(m.Name)
}

func (m *Model) tasksView() string {
	var renderedTasks []string

	for i := range m.Tasks {
		renderedTasks = append(renderedTasks, m.renderTask(i))
	}

	return lipgloss.NewStyle().
		Padding(0, 2, 0, 2).
		Render(lipgloss.JoinVertical(lipgloss.Left, renderedTasks...))
}

func (m *Model) renderTask(taskID int) string {
	task := &m.Tasks[taskID]

	paddingWidth := 4
	statusWidth := 4
	maxIndexWidth := len(strconv.Itoa(len(m.Tasks) + 1))
	indexMargin := 1
	marginWidth := 4
	nameWidth := m.width - paddingWidth - marginWidth - statusWidth - maxIndexWidth - indexMargin

	indexStyle := lipgloss.NewStyle().Width(maxIndexWidth).MarginRight(indexMargin)
	taskNameStyle := lipgloss.NewStyle().Width(nameWidth)

	row := lipgloss.JoinHorizontal(
		lipgloss.Left,
		indexStyle.Render(strconv.Itoa(taskID+1)),
		taskNameStyle.Render(task.Name),
		renderStatus(task.Status),
	)

	if taskID == m.cursor {
		return m.styles.Task.Copy().BorderForeground(m.styles.ActiveTaskColor).Render(row)
	}

	return m.styles.Task.Render(row)
}
